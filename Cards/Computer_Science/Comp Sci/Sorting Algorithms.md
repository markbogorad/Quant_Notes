up:: [[Computer Science MOC]]
tags:: #Programming  
# Sorting Algos
- Created with loops

| Sorting Algorithm | Description                                                                                                                                                                                                  | Complexity                                                                                  | C Implementation                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Bubble Sort       | Repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.                                                                                                | O(n²) average and worst-case (see [[Program Running Time (Big O)]])                         | ```c void bubbleSort(int arr[], int n) { for (int i = 0; i < n-1; i++) for (int j = 0; j < n-i-1; j++) if (arr[j] > arr[j+1]) { int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } ```                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Selection Sort    | Divides the list into a sorted and an unsorted region, and repeatedly selects the smallest (or largest) element from the unsorted region and moves it to the end of the sorted region.                       | O(n²) average and worst-case                                                                | ```c void selectionSort(int arr[], int n) { for (int i = 0; i < n-1; i++) { int min_idx = i; for (int j = i+1; j < n; j++) if (arr[j] < arr[min_idx]) min_idx = j; int temp = arr[min_idx]; arr[min_idx] = arr[i]; arr[i] = temp; } } ```                                                                                                                                                                                                                                                                                                                                                                                |
| Insertion Sort    | Builds the sorted array one item at a time by repeatedly picking the next item and inserting it into the correct position among the previously sorted items.                                                 | O(n²) average and worst-case, O(n) best-case                                                | ```c void insertionSort(int arr[], int n) { for (int i = 1; i < n; i++) { int key = arr[i]; int j = i - 1; while (j >= 0 && arr[j] > key) { arr[j + 1] = arr[j]; j = j - 1; } arr[j + 1] = key; } } ```                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Merge Sort        | A divide-and-conquer algorithm that divides the list into two halves, sorts each half, and then merges the sorted halves.                                                                                    | O(n log n) average and worst-case                                                           | ```c void merge(int arr[], int l, int m, int r) { int n1 = m - l + 1; int n2 = r - m; int L[n1], R[n2]; for (int i = 0; i < n1; i++) L[i] = arr[l + i]; for (int j = 0; j < n2; j++) R[j] = arr[m + 1 + j]; int i = 0, j = 0, k = l; while (i < n1 && j < n2) { if (L[i] <= R[j]) arr[k++] = L[i++]; else arr[k++] = R[j++]; } while (i < n1) arr[k++] = L[i++]; while (j < n2) arr[k++] = R[j++]; } void mergeSort(int arr[], int l, int r) { if (l < r) { int m = l + (r - l) / 2; mergeSort(arr, l, m); mergeSort(arr, m + 1, r); merge(arr, l, m, r); } } ```                                                        |
| Quick Sort        | A divide-and-conquer algorithm that selects a 'pivot' element and partitions the array into elements less than the pivot and elements greater than the pivot, and then recursively sorts the partitions.     | O(n log n) average case, O(n²) worst-case                                                   | ```c int partition(int arr[], int low, int high) { int pivot = arr[high]; int i = (low - 1); for (int j = low; j <= high - 1; j++) { if (arr[j] < pivot) { i++; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } int temp = arr[i + 1]; arr[i + 1] = arr[high]; arr[high] = temp; return (i + 1); } void quickSort(int arr[], int low, int high) { if (low < high) { int pi = partition(arr, low, high); quickSort(arr, low, pi - 1); quickSort(arr, pi + 1, high); } } ```                                                                                                                                        |
| Heap Sort         | Converts the array into a heap data structure, then repeatedly extracts the maximum element from the heap and rebuilds the heap.                                                                             | O(n log n) average and worst-case                                                           | ```c void heapify(int arr[], int n, int i) { int largest = i; int left = 2 * i + 1; int right = 2 * i + 2; if (left < n && arr[left] > arr[largest]) largest = left; if (right < n && arr[right] > arr[largest]) largest = right; if (largest != i) { int temp = arr[i]; arr[i] = arr[largest]; arr[largest] = temp; heapify(arr, n, largest); } } void heapSort(int arr[], int n) { for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i); for (int i = n - 1; i > 0; i--) { int temp = arr[0]; arr[0] = arr[i]; arr[i] = temp; heapify(arr, n, 0); } } ```                                                           |
| Radix Sort        | Non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by individual digits that share the same significant position and value.                                        | O(nk) where n is the number of elements and k is the number of digits in the largest number | ```c int getMax(int arr[], int n) { int mx = arr[0]; for (int i = 1; i < n; i++) if (arr[i] > mx) mx = arr[i]; return mx; } void countSort(int arr[], int n, int exp) { int output[n]; int i, count[10] = {0}; for (i = 0; i < n; i++) count[(arr[i] / exp) % 10]++; for (i = 1; i < 10; i++) count[i] += count[i - 1]; for (i = n - 1; i >= 0; i--) { output[count[(arr[i] / exp) % 10] - 1] = arr[i]; count[(arr[i] / exp) % 10]--; } for (i = 0; i < n; i++) arr[i] = output[i]; } void radixSort(int arr[], int n) { int m = getMax(arr, n); for (int exp = 1; m / exp > 0; exp *= 10) countSort(arr, n, exp); } ``` |
| Bucket Sort       | Divides the array into several buckets, sorts each bucket individually (often using another sorting algorithm or by recursively applying bucket sort), and then concatenates the sorted buckets.             | O(n + k) where n is the number of elements and k is the number of buckets                   | ```c void bucketSort(float arr[], int n) { vector<float> b[n]; for (int i = 0; i < n; i++) { int bi = n * arr[i]; b[bi].push_back(arr[i]); } for (int i = 0; i < n; i++) sort(b[i].begin(), b[i].end()); int index = 0; for (int i = 0; i < n; i++) for (int j = 0; j < b[i].size(); j++) arr[index++] = b[i][j]; } ```                                                                                                                                                                                                                                                                                                  |
| Shell Sort        | An optimization over insertion sort that allows the exchange of far-apart elements. The array is initially divided into a large gap and then sorted, progressively reducing the gap and re-sorting the list. | O(n log n) best-case, O(n²) worst-case                                                      | ```c void shellSort(int arr[], int n) { for (int gap = n / 2; gap > 0; gap /= 2) { for (int i = gap; i < n; i++) { int temp = arr[i]; int j; for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) arr[j] = arr[j - gap]; arr[j] = temp; } } } ```                                                                                                                                                                                                                                                                                                                                                                      |
